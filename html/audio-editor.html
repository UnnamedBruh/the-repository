<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audio Editor</title>
    <style>
        /* Basic styling for the UI */
        #controls {
            margin: 10px 0;
        }
        button, input[type="range"], input[type="number"] {
            margin: 5px;
        }
    </style>
</head>
<body>
    <input type="file" id="fileInput" />
    <div id="controls">
        <button id="normalizeBtn">Normalize</button>
        <button id="applyGainBtn">Apply Gain</button>
        <input type="range" id="gainSlider" min="0" max="2" step="0.1" value="1" />
        <button id="applyReverbBtn">Apply Reverb</button>
        <input type="number" id="echoInput" min="0" step="0.1" value="1" />
        <input type="number" id="likelinessInput" min="1" step="0.1" value="5" />
        <button id="playBtn">Play</button>
        <button id="downloadBtn">Download</button>
    </div>
    <script>
        class AudioProcessor {
            constructor(audioData = new Float32Array([])) {
                this.audioData = audioData;
                this.sampleRate = 48000; // Default sample rate
            }

            normalize() {
                if (this.audioData.length === 0) return;
                const max = Math.max(...this.audioData);
                const min = Math.min(...this.audioData);
                const range = max - min;
                if (range === 0) return;
                for (let i = 0; i < this.audioData.length; i++) {
                    this.audioData[i] = (this.audioData[i] - min) / range;
                }
            }

            applyGain(gain) {
                if (gain < 0) {
                    console.warn("Gain should be a positive value.");
                    return;
                }
                for (let i = 0; i < this.audioData.length; i++) {
                    this.audioData[i] *= gain;
                }
            }

            load(array) {
                if (!(array instanceof Float32Array)) {
                    console.error("Input must be a Float32Array.");
                    return;
                }
                this.audioData = array;
            }

            applySimpleReverb(likelinessOfEcho, echo, trailEcho = false) {
                if (likelinessOfEcho <= 1) {
                    console.warn("LikelinessOfEcho should be greater than 1.");
                }
                if (echo <= 0) {
                    console.warn("Echo strength should be a positive value.");
                    return;
                }
                const output = new Float32Array(this.audioData.length);
                let reverb = 0;
                const ec = echo / 10;
                const len = output.length;
                for (let i = 0; i < len; i++) {
                    reverb = Math.abs((reverb / likelinessOfEcho) + (this.audioData[i] * ec));
                    output[i] = this.audioData[i] + (reverb * 10);
                }
                if (trailEcho) {
                    while (reverb > 0.02) {
                        reverb = (reverb / likelinessOfEcho);
                        output[i] = reverb;
                    }
                }
                this.audioData.set(output);
            }

            convertToWav() {
                const numChannels = 1; // Mono audio
                const buffer = new ArrayBuffer(44 + this.audioData.length * 2);
                const view = new DataView(buffer);
                
                // RIFF chunk descriptor
                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + this.audioData.length * 2, true);
                writeString(view, 8, 'WAVE');
                
                // fmt sub-chunk
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, this.sampleRate, true);
                view.setUint32(28, this.sampleRate * 2, true);
                view.setUint16(32, 2, true);
                view.setUint16(34, 16, true);
                
                // data sub-chunk
                writeString(view, 36, 'data');
                view.setUint32(40, this.audioData.length * 2, true);
                
                // Write audio data
                let offset = 44;
                for (let i = 0; i < this.audioData.length; i++) {
                    view.setInt16(offset, this.audioData[i] * 32767, true);
                    offset += 2;
                }
                
                function writeString(view, offset, string) {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                }
                
                return new Blob([view], { type: 'audio/wav' });
            }
        }

        const fileInput = document.getElementById('fileInput');
        const normalizeBtn = document.getElementById('normalizeBtn');
        const applyGainBtn = document.getElementById('applyGainBtn');
        const gainSlider = document.getElementById('gainSlider');
        const applyReverbBtn = document.getElementById('applyReverbBtn');
        const echoInput = document.getElementById('echoInput');
        const likelinessInput = document.getElementById('likelinessInput');
        const playBtn = document.getElementById('playBtn');
        const downloadBtn = document.getElementById('downloadBtn');

        let audioProcessor = null;
        let audioContext = null;
        let sourceNode = null;

        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const arrayBuffer = await file.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    const channelData = audioBuffer.getChannelData(0);
                    audioProcessor = new AudioProcessor(new Float32Array(channelData));
                    console.log('Audio loaded.');
                } catch (error) {
                    console.error('Error processing audio file:', error);
                }
            }
        });

        normalizeBtn.addEventListener('click', () => {
            if (audioProcessor) {
                audioProcessor.normalize();
                console.log('Normalization applied.');
            }
        });

        applyGainBtn.addEventListener('click', () => {
            if (audioProcessor) {
                const gain = parseFloat(gainSlider.value);
                audioProcessor.applyGain(gain);
                console.log(`Gain applied: ${gain}`);
            }
        });

        applyReverbBtn.addEventListener('click', () => {
            if (audioProcessor) {
                const echo = parseFloat(echoInput.value);
                const likelinessOfEcho = parseFloat(likelinessInput.value);
                audioProcessor.applySimpleReverb(likelinessOfEcho, echo, true);
                console.log(`Reverb applied: Echo=${echo}, Likeliness=${likelinessOfEcho}`);
            }
        });

        playBtn.addEventListener('click', () => {
            if (audioProcessor && audioContext) {
                if (sourceNode) sourceNode.disconnect();
                sourceNode = audioContext.createBufferSource();
                const audioBuffer = audioContext.createBuffer(1, audioProcessor.audioData.length, audioProcessor.sampleRate);
                audioBuffer.copyToChannel(audioProcessor.audioData, 0);
                sourceNode.buffer = audioBuffer;
                sourceNode.connect(audioContext.destination);
                sourceNode.start();
                console.log('Playback started.');
            }
        });

        downloadBtn.addEventListener('click', () => {
            if (audioProcessor) {
                const wavBlob = audioProcessor.convertToWav();
                const url = URL.createObjectURL(wavBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'edited-audio.wav';
                a.click();
                URL.revokeObjectURL(url);
                console.log('Download started.');
            }
        });
    </script>
</body>
</html>
